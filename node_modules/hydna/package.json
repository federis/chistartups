{
  "name": "hydna",
  "version": "2.0.0",
  "description": "Hydna client",
  "keywords": [
    "hermes",
    "wink",
    "client",
    "hydna",
    "real-time",
    "messaging"
  ],
  "homepage": "https://github.com/hydna/node-hydna",
  "author": {
    "name": "Hydna AB",
    "email": "info@hydna.com",
    "url": "http://www.hydna.com/"
  },
  "main": "./index",
  "scripts": {
    "test": "scripts/test.js -r test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/hydna/node-hydna.git"
  },
  "os": [
    "macos",
    "linux",
    "darwin"
  ],
  "engines": {
    "node": ">=0.4.7"
  },
  "readme": "Hydna for nodejs\n================\n\nThe node.js hydna library is a straight-forward implementation of the wink binary protocol. The module has been closely modeled to the native node.js modules and the usage pattern should come naturally to developers using other node.js modules. The module does not have any external dependencies.\n\nCreating a connection:\n\n    var hydna = require('hydna');\n    var channel = hydna.createChannel('localhost', 'rw');\n\n    channel.on('connect', function() {\n      // read/write connection is ready to use \n    });\n\n    channel.on('error', function() {\n      // an error occured when connecting\n    });\n\nA read/write channel is opened and event-listeners for connect and error are attached to the channel.\n\nSending Data:\n\n    var hydna = require('hydna');\n    var channel = hydna.createChannel('localhost', 'w');\n\n    channel.on('connect', function() {\n      var message = 'Hello World!';\n      channel.write(message, 'utf8');\n    });\n\nOpens up a channel for writing and, when the connection has been established and the connect event has been emitted, writes a message.\n\nReceiving data:\n\n    var hydna = require('hydna');\n    var channel = hydna.createChannel('localhost', 'r');\n    \n    channel.setEncoding('utf8');\n    \n    channel.on('data', function(data) {\n      console.log(data);\n    });\n\nOpens up a channel for reading and, when the data arrives and the data event is emitted, writes the received data to the console.\n\n\n## Installation\n\nThe easiest way to install this library is via npm:\n\n    $ npm install hydna\n\n\n## Test \n\nThe test suite requires a running server instance with the behaviors found `test/behaviors` loaded.\n\nThe default server address is `testing.hydna.net`. This can be overridden via the environment variable `TEST_ADDRESS`.\n\nTo run the test suite:\n\n    $  TEST_ADDRESS=<server_address_and_port> npm test \n\n\n## API Specification\n\nThe node.js hydna client library consists of a single module — hydna — that\ncontains everything that is necessary to communicate over hydna.\n\n### hydna.PAYLOAD_MAX_SIZE\n\nReturns the maximum payload size.\n\n\n### hydna.origin=<hostname>\n  \nSets the origin identity that should be sent to the server on handshake.\n\n\n### hydna.agent=node-winsock-client/<version>\n  \nSets the agent identity that should be sent to the server on handshake.\n\n\n### hydna.send(url, data, [prio=0], [callback])\n\nSend's a message to specified `'url'` whithout creating a new `hydna.Channel` instance.\n\nNote: This function is a complement to the ordinary Hydna Channel and should be used when a persistent connection is redundant.\n\n\n### hydna.dispatch(url, data, [callback])\n\nDispatch a signal on the specified `'url'` whithout creating a new `hydna.Channel` instance.\n\nNote: This function is a complement to the ordinary Hydna Channel and should be used when a persistent connection is redundant.\n\n\n### hydna.createChannel(url, mode, [options], [callback])\n\nOpens a Channel to the specified ´'url'´.\n\nThis function is asynchronous. When the `'connect'` event is emitted once connected. If there is a problem connecting, the `'connect'` event will not be emitted, the 'error' event will be emitted with the exception.\n\nAvailable modes:\n* read (r) - Open channel in read mode\n* write (w) - Open channel in write mode\n* readwrite (rw) - Open channel in read-write mode.\n* +emit(e) - Open channel with emit-signal support (e.g. 'rw+emit').\n\nAvailable options:\n* `disableMultiplex`, disables multiplexing of channels over one socket. Default is `false` (multiplex is enabled),\n\nThis example opens a Channel and writes data too it. The same data\nis received :\n\n    var hydna = require('hydna');\n    var channel = hydna.createChannel('localhost', 'w');\n    channel.write('Hello World!');\n\n\n### hydna.Channel\n\nThis object is an abstraction of a TCP or UNIX socket. hydna.Channel instance implement a duplex stream interface. They can be created by the user and used as a client (with connect()) or they can be created by Node and passed to the user through the 'connection' event of a server.\n\nhydna.Channel instances are EventEmitters with the following events:\n\nEvent: `'connect'`\n`function (data) { }`\n\nEmitted when a channel connection successfully is established. See connect(). The `'message'` argument may or may not contain an initial message from server.\n\nEvent: `'data'`\n`function (data) { }`\n\nEmitted when data is received. The argument data will be a Buffer or String.  Encoding of data is set by channel.setEncoding(). \n\nEvent: `'drain'`\n`function () { }`\n\nEmitted when the write buffer becomes empty. Can be used to throttle uploads.\n\nEvent: `'error'`\n`function (exception) { }`\n\nEmitted when an error occurs. The `'close'` event will be called directly  following this event.\n\nEvent: `'close'`\n`function (had_error) { }`\n\nEmitted once the channel is fully closed. The argument had_error is a boolean which says if the channel was closed due to an error.\n\nEvent: `'signal'`\n`function (data) { }`\n\nEmitted when remote server send's a signal.\n\n#### Channel.readable\n\nReturns `true` if channel is readable, else false.\n\n#### Channel.writable\n\nReturns `true` if channel is writable, else false.\n\n#### Channel.emitable\n\nReturns `true` if channel is emitable, else false.\n\n\n#### Channel.readyState\n\nEither `'closed'`, `'closing'`, `'open'`, `'opening'`, \n`'read'`, `'write'`, `'readwrite'` and/or `'+emit'`.\n\n\n#### Channel.write(data,  priority=0)\n\nSends data on the channel.\n\nReturns ´true´ if the entire data was flushed successfully to the underlying connection. Returns `false` if all or part of the data was queued in user memory. ´'drain'´ will be emitted when the buffer is again free.\n\n\n#### Channel.dispatch(data)\n\nDispatch a signal on the channel.\n\nReturns ´true´ if the signal was flushed successfully to the underlying connection. Returns `false` if the all or part of the signal was queued in user memory. ´'drain'´ will be emitted when the buffer is again free.\n\nExample:\n\n    var hydna = require('hydna');\n    var channel = hydna.createChannel('localhost', 'read+emit');\n    channel.on('signal', function(message) {\n      if (message == 'pong') {\n        console.log('Recevied pong from server');\n      }\n    });\n    channel.dispatch('ping');\n\n\n\n#### Channel.end([data])\n\nCloses channel for reading, writing and emitting. The optional `data` is sent to the server.\n\nExample:\n\n    var hydna = require('hydna');\n    var channel = hydna.createChannel('localhost', 'read');\n    channel.end('good bye!');\n\n\n#### Channel.destroy()\n\nCloses channel for reading, writing and emitting.\n\n## Examples\n\nSee directory \"./examples\" for different use-cases.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/hydna/node-hydna/issues"
  },
  "_id": "hydna@2.0.0",
  "_from": "hydna@"
}
